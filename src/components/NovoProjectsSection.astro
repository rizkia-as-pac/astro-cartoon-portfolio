---
import { getCollection } from "astro:content";

const base = import.meta.env.BASE_URL;
const withBase = (path: string) => `${base}${path.replace(/^\//, "")}`;
const isExternalUrl = (href: string) => /^(https?:)?\/\//i.test(href);

const entries = (await getCollection("projects")) as any[];

function resolveSlug(entry: any) {
  if (entry?.slug) return entry.slug;
  if (entry?.id) return entry.id.split("/").pop()?.replace(/\.md$/, "") || "";
  return "";
}

function normalizeAsset(src: any) {
  if (typeof src !== "string" || !src.trim()) return "";
  // external url or protocol-relative
  if (isExternalUrl(src)) return src;
  // absolute path from /public
  if (src.startsWith("/")) return withBase(src);
  // relative string (biarkan apa adanya)
  return src;
}

function getCover(entry: any) {
  const g = entry?.data?.gallery;
  const first = Array.isArray(g) && g.length > 0 ? g[0] : "";
  return normalizeAsset(first) || withBase("/svg/project4.svg");
}

const projectsData = entries
  .map((p) => {
    const slug = resolveSlug(p);
    if (!slug) return null;

    const internalDetail = withBase(`/projects/${slug}`);

    // Kalau link di frontmatter itu external, pakai itu.
    // Kalau kosong / bukan external, fallback ke internal detail page.
    const linkRaw = typeof p?.data?.link === "string" ? p.data.link.trim() : "";
    const href = linkRaw ? (isExternalUrl(linkRaw) ? linkRaw : internalDetail) : internalDetail;

    const techs = (p?.data?.techStack ?? [])
      .map((t: any) => t?.name)
      .filter((x: any) => typeof x === "string" && x.trim().length > 0);

    return {
      slug,
      title: p?.data?.title ?? "Untitled",
      description: p?.data?.excerpt ?? "",
      technologies: techs,
      href,                 // satu sumber link aja biar simpel
      cover: getCover(p),   // sudah normalized
    };
  })
  .filter(Boolean) as Array<{
    slug: string;
    title: string;
    description: string;
    technologies: string[];
    href: string;
    cover: string;
  }>;

const images = projectsData.map((p) => p.cover).filter((x) => typeof x === "string" && x.trim());
const safeImages = images.length > 0 ? images : [withBase("/svg/project1.svg")];

const projectsConfig = {
  images: safeImages,
  projects: projectsData,
};
---

<section class="projects-section">
  <div class="projects-container">
    <h2 class="projects-title">Projects</h2>

    <div class="projects-carousel-wrapper">
      <div class="mask">
        <div
          role="region"
          aria-roledescription="carousel"
          class="coverflow-carousel"
          draggable="false"
          style="display:flex;position:relative;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;touch-action:pan-y"
        >
          <ul
            role="group"
            id="projects-carousel-ul"
            style="display:flex;position:relative;list-style-type:none;padding:0;margin:0;justify-content:flex-start;flex-direction:row;gap:0px;align-items:center;width:100%;height:100%;max-height:100%;max-width:100%;"
          >
            {projectsConfig.images.map((imageSrc, index) => (
              <li
                class="ticker-item"
                aria-hidden="false"
                aria-posinset={index + 1}
                aria-setsize={projectsConfig.images.length}
                style="flex-grow:0;flex-shrink:0;position:relative;height:fit-content;z-index:1000;transform:none"
              >
                <img
                  draggable="false"
                  src={imageSrc}
                  alt={`Project ${index + 1}`}
                  class="coverflow-item"
                  style="transform:perspective(500px)"
                  loading="lazy"
                />
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>

    <div class="project-description-area" id="project-description-area">
      <div class="project-description-viewport">
        <div class="project-description-track" id="project-description-track">
          {projectsConfig.projects.map((project, index) => {
            const isExternal = isExternalUrl(project.href);

            return (
              <div class="project-content-item" data-project-index={index}>
                <h3 class="project-title">{project.title}</h3>

                <p class="project-description">{project.description}</p>

                <div class="project-technologies">
                  {project.technologies.map((tech) => (
                    <span class="technology-tag">{tech}</span>
                  ))}
                </div>

                <div class="project-links">
                  <a
                    href={project.href}
                    class="project-link"
                    target={isExternal ? "_blank" : undefined}
                    rel={isExternal ? "noopener noreferrer" : undefined}
                  >
                    See more <span style="font-size: 1.2rem;">â†’</span>
                  </a>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  </div>
</section>

<script
  type="application/json"
  id="projects-data"
  set:html={JSON.stringify(projectsConfig.projects)}
/>

<script>
  (function initProjectsCarousel() {
    const carouselUl = document.getElementById("projects-carousel-ul");
    const carouselContainer = carouselUl?.parentElement;
    const items = carouselUl?.querySelectorAll(".ticker-item");
    const images = carouselUl?.querySelectorAll(".coverflow-item");

    if (!carouselUl || !carouselContainer || !items || !images) {
      console.error("Projects carousel elements not found");
      return;
    }

    // keep (optional) load data; not used in your current logic
    JSON.parse(document.getElementById("projects-data")?.textContent || "[]");

    const descriptionTrack = document.getElementById("project-description-track");
    const descriptionViewport = document.querySelector(".project-description-viewport");

    let currentProjectIndex = 0;
    let isScrolling = false;
    let currentTranslateY = 0;

    function initializeDescriptionPosition() {
      if (!descriptionTrack || !descriptionViewport) return;

      const items = descriptionTrack.querySelectorAll(".project-content-item");
      if (items.length === 0) return;

      const firstItem = items[0];
      requestAnimationFrame(() => {
        const firstItemTop = firstItem.offsetTop;
        currentTranslateY = -firstItemTop;
        descriptionTrack.style.transform = `translateY(${currentTranslateY}px)`;
      });
    }

    function updateProjectDescription(projectIndex) {
      if (!descriptionTrack || !descriptionViewport || isScrolling) return;
      if (projectIndex === currentProjectIndex) return;

      const items = descriptionTrack.querySelectorAll(".project-content-item");
      if (items.length === 0) return;
      if (projectIndex < 0 || projectIndex >= items.length) return;

      const targetItem = items[projectIndex];
      const targetY = -targetItem.offsetTop;

      isScrolling = true;
      const startY = currentTranslateY;
      const startTime = performance.now();
      const duration = 500;

      function animateScroll(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeInOutCubic =
          progress < 0.5
            ? 4 * progress * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        currentTranslateY = startY + (targetY - startY) * easeInOutCubic;
        descriptionTrack.style.transform = `translateY(${currentTranslateY}px)`;

        if (progress < 1) requestAnimationFrame(animateScroll);
        else {
          currentTranslateY = targetY;
          currentProjectIndex = projectIndex;
          isScrolling = false;
        }
      }

      requestAnimationFrame(animateScroll);
    }

    const itemWidth = 350;
    const gap = 0;
    const totalItems = items.length;
    const cloneCount = totalItems;

    for (let i = 0; i < cloneCount; i++) {
      const originalItem = items[i];
      const clone = originalItem.cloneNode(true);
      clone.classList.add("clone-item");
      clone.setAttribute("aria-hidden", "true");
      carouselUl.insertBefore(clone, items[0]);
    }

    for (let i = 0; i < cloneCount; i++) {
      const originalItem = items[i];
      const clone = originalItem.cloneNode(true);
      clone.classList.add("clone-item");
      clone.setAttribute("aria-hidden", "true");
      carouselUl.appendChild(clone);
    }

    const allItems = carouselUl.querySelectorAll(".ticker-item");
    const allImages = carouselUl.querySelectorAll(".coverflow-item");

    let currentX = 0;
    let isDragging = false;
    let startX = 0;
    let startScrollLeft = 0;
    let lastX = 0;
    let lastTime = 0;
    let animationFrameId = null;
    let dragDistance = 0;
    let clickedItemIndex = null;

    let autoPlayTimer = null;
    let isAutoPlaying = true;
    const autoPlayInterval = 4000;
    let lastProjectIndex = -1;

    function getOffset(itemIndex, scrollX) {
      const containerCenter = carouselContainer.offsetWidth / 2;
      const itemStart = itemIndex * (itemWidth + gap);
      const itemCenterX = itemStart + scrollX + itemWidth / 2;
      return itemCenterX - containerCenter;
    }

    function lerp(input, inputRange, outputRange) {
      if (input <= inputRange[0]) return outputRange[0];
      if (input >= inputRange[inputRange.length - 1]) return outputRange[outputRange.length - 1];

      for (let i = 0; i < inputRange.length - 1; i++) {
        if (input >= inputRange[i] && input <= inputRange[i + 1]) {
          const t = (input - inputRange[i]) / (inputRange[i + 1] - inputRange[i]);
          if (typeof outputRange[i] === "string" && outputRange[i].includes("%")) {
            const start = parseFloat(outputRange[i]);
            const end = parseFloat(outputRange[i + 1]);
            return start + (end - start) * t + "%";
          }
          return outputRange[i] + (outputRange[i + 1] - outputRange[i]) * t;
        }
      }
      return outputRange[0];
    }

    function getTransformFromOffset(offset) {
      const rotateY = lerp(offset, [-200, 0, 200], [20, 0, -20]);
      const scale = lerp(offset, [-200, 0, 200], [0.7, 1, 0.7]);
      const x = lerp(offset, [-800, -200, 200, 800], ["100%", "0%", "0%", "-100%"]);
      const zIndex = Math.max(0, Math.round(1000 - Math.abs(offset)));
      return { rotateY, scale, x, zIndex };
    }

    function updateTransforms() {
      allItems.forEach((item, virtualIndex) => {
        const img = item.querySelector(".coverflow-item");
        if (!img) return;

        const offset = getOffset(virtualIndex, currentX);
        const t = getTransformFromOffset(offset);

        item.style.zIndex = String(t.zIndex);

        const xPx = t.x === "0%" ? 0 : (parseFloat(t.x) / 100) * itemWidth;
        img.style.transform = `perspective(500px) translateX(${xPx}px) rotateY(${t.rotateY}deg) scale(${t.scale})`;
      });
    }

    function getSnapPosition(virtualIndex) {
      const containerCenter = carouselContainer.offsetWidth / 2;
      const itemStart = virtualIndex * (itemWidth + gap);
      return containerCenter - itemStart - itemWidth / 2;
    }

    function checkLoopJump() {
      if (isDragging || animationFrameId) return;

      const singleSetWidth = totalItems * (itemWidth + gap);

      if (currentX > -singleSetWidth / 2) {
        currentX -= singleSetWidth;
        carouselUl.style.transition = "none";
        updateCarouselPosition();
        setTimeout(() => (carouselUl.style.transition = ""), 0);
      }

      const maxScroll = -singleSetWidth * 1.5;
      if (currentX < maxScroll) {
        currentX += singleSetWidth;
        carouselUl.style.transition = "none";
        updateCarouselPosition();
        setTimeout(() => (carouselUl.style.transition = ""), 0);
      }
    }

    function findNearestItem() {
      const containerCenter = carouselContainer.offsetWidth / 2;
      let nearestIndex = totalItems;
      let minDistance = Infinity;

      allItems.forEach((item, virtualIndex) => {
        const itemStart = virtualIndex * (itemWidth + gap);
        const itemCenterX = itemStart + currentX + itemWidth / 2;
        const distance = Math.abs(itemCenterX - containerCenter);
        if (distance < minDistance) {
          minDistance = distance;
          nearestIndex = virtualIndex;
        }
      });

      return nearestIndex;
    }

    function getRealProjectIndex(virtualIndex) {
      if (virtualIndex < cloneCount) return virtualIndex;
      if (virtualIndex < cloneCount + totalItems) return virtualIndex - cloneCount;
      return virtualIndex - cloneCount - totalItems;
    }

    function updateProjectDescriptionFromCarousel() {
      const nearestVirtualIndex = findNearestItem();
      const realIndex = getRealProjectIndex(nearestVirtualIndex);
      if (realIndex !== lastProjectIndex) {
        lastProjectIndex = realIndex;
        updateProjectDescription(realIndex);
      }
    }

    function updateProjectDescriptionForVirtualIndex(virtualIndex) {
      const realIndex = getRealProjectIndex(virtualIndex);
      if (realIndex !== lastProjectIndex) {
        lastProjectIndex = realIndex;
        updateProjectDescription(realIndex);
      }
    }

    function animateTo(targetX, duration = 450) {
      const startX = currentX;
      const startTime = performance.now();

      function animate(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeOutCubic = 1 - Math.pow(1 - progress, 3);

        currentX = startX + (targetX - startX) * easeOutCubic;
        updateCarouselPosition();

        if (progress < 1) animationFrameId = requestAnimationFrame(animate);
        else {
          animationFrameId = null;
          checkLoopJump();
          updateProjectDescriptionFromCarousel();
        }
      }

      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(animate);
    }

    function updateCarouselPosition() {
      carouselUl.style.transform = `translateX(${currentX}px)`;
      updateTransforms();
      checkLoopJump();
    }

    function goToItem(virtualIndex) {
      updateProjectDescriptionForVirtualIndex(virtualIndex);
      animateTo(getSnapPosition(virtualIndex));
    }

    function nextItem() {
      goToItem(findNearestItem() + 1);
    }

    function startAutoPlay() {
      if (autoPlayTimer) return;
      autoPlayTimer = window.setInterval(() => {
        if (!isDragging && !animationFrameId && isAutoPlaying) nextItem();
      }, autoPlayInterval);
    }

    function stopAutoPlay() {
      if (autoPlayTimer) {
        clearInterval(autoPlayTimer);
        autoPlayTimer = null;
      }
    }

    function pauseAutoPlay() {
      stopAutoPlay();
      setTimeout(() => {
        if (isAutoPlaying) startAutoPlay();
      }, 5000);
    }

    carouselUl.addEventListener("mousedown", (e) => {
      const clickedElement = e.target.closest(".ticker-item");
      clickedItemIndex = clickedElement ? Array.from(allItems).indexOf(clickedElement) : null;

      isDragging = true;
      startX = e.pageX;
      startScrollLeft = currentX;
      lastX = e.pageX;
      lastTime = performance.now();
      dragDistance = 0;

      carouselUl.style.cursor = "grabbing";
      pauseAutoPlay();

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    carouselUl.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      e.preventDefault();

      const x = e.pageX - startX;
      dragDistance = Math.abs(x);

      currentX = startScrollLeft + x;
      updateCarouselPosition();

      lastX = e.pageX;
      lastTime = performance.now();
    });

    carouselUl.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      carouselUl.style.cursor = "grab";

      const nearestIndex = findNearestItem();
      updateProjectDescriptionForVirtualIndex(nearestIndex);
      animateTo(getSnapPosition(nearestIndex));

      dragDistance = 0;
      clickedItemIndex = null;

      pauseAutoPlay();
    });

    carouselUl.addEventListener("mouseleave", () => {
      if (!isDragging) return;
      isDragging = false;
      carouselUl.style.cursor = "grab";
    });

    carouselUl.addEventListener("touchstart", (e) => {
      isDragging = true;
      startX = e.touches[0].pageX;
      startScrollLeft = currentX;
      lastX = e.touches[0].pageX;
      lastTime = performance.now();

      pauseAutoPlay();

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    carouselUl.addEventListener("touchmove", (e) => {
      if (!isDragging) return;
      const x = e.touches[0].pageX - startX;

      currentX = startScrollLeft + x;
      updateCarouselPosition();

      lastX = e.touches[0].pageX;
      lastTime = performance.now();
    });

    carouselUl.addEventListener("touchend", () => {
      if (!isDragging) return;
      isDragging = false;

      const nearestIndex = findNearestItem();
      updateProjectDescriptionForVirtualIndex(nearestIndex);
      animateTo(getSnapPosition(nearestIndex));

      pauseAutoPlay();
    });

    carouselUl.style.cursor = "grab";
    allImages.forEach((img) => (img.style.cursor = "pointer"));

    // Start position & init
    const centerVirtualIndex = totalItems;
    currentX = getSnapPosition(centerVirtualIndex);
    updateCarouselPosition();
    updateTransforms();
    initializeDescriptionPosition();
    currentProjectIndex = 0;
    startAutoPlay();
  })();
</script>

